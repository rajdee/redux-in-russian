# Хранилище (Store)

Хранилище содержит все [дерево состояний](../Glossary.md#state) вашего приложения.
Единственный способ поменять состояние внутри него - это направить [dispatch (action)](../Glossary.md#action) на него.

Хранилище - это не класс. Это просто объект с некоторыми методами в нем. Чтобы его создать, передайте вашу корневую [функцию редюсера](../Glossary.md#reducer) в [`createStore`](createStore.md)

>##### Примечания для пользователей Flux
>Если вы пришли из Flux, то есть одно важное отличие, которое необходимо понять. Redux не имеет Диспетчера (Dispatcher) или поддержки множественных хранилищ. **Вместо этого здесь только одно хранилище, с одной корневой [функцией редюсера](../Glossary.md#reducer).** Если ваше приложение растет, то вместо добавления хранилищ, вы разделяете корневой редюсер на более мелкие редюсеры, независимо работающие в разных частях дерева состояний. Для их объединения может помочь [`combineReducers`](combineReducers.md). Можно провести аналогию с тем, что есть один корневой компонент в приложении React, но состоящий из множества маленьких компонентов.

### Методы хранилища

- [`getState()`](#getState)
- [`dispatch(action)`](#dispatch)
- [`subscribe(listener)`](#subscribe)
- [`replaceReducer(nextReducer)`](#replaceReducer)

## Методы хранилища

### <a id='getState'></a>[`getState()`](#getState)

Возвращает текущее состояние вашего приложения.
Оно равно последнему возвращенному значению из редюсера хранилища.

#### Возвращает

*(any)*: Текущее состояние вашего приложения.

<hr>

### <a id='dispatch'></a>[`dispatch(action)`](#dispatch)

Отправляет действие. Это единственный способ изменить состояние.

Функция редюсера хранилища будет вызвана с текущим [`getState()`](#getState) результатом и переданным `dispatch (action)` синхронно. Возвращенное значения будет содержать следующие состояние. Оно будет возвращено из [`getState()`](#getState) сразу же и подписчики будут немедленно уведомлены.

>##### Примечания для пользователей Flux
>Если вы попытаетесь вызвать `dispatch` изнутри [редюсера](../Glossary.md#reducer), то возникнет ошибка "Редюсеры не могут отправлять действия". Это аналогично ошибке во Flux "Нельзя отправлять в середине отправки", но это не вызвано проблемами связанными с ним. Во Flux отправлять запрещено пока Хранилище не обработает действие и запустит обновление. Это сделано для того, чтобы сделать невозможным отправку действий из хуков жизненного цикла компонент или других слабых мест.

>В Redux, подписки вызванные после корневого редюсера возвращают новое состояние, поэтому вы можете отправлять в подписанных слушателей. Вам только запрещено отправлять внутри редюсера, потому что они не должны вызывать побочных эффектов. Если вы хотите вызывать побочный эффект вызванный в ответ на действие, то правильно это сделать в потенциально асинхронном [генераторе действий](../Glossary.md#action-creator).

#### Параметры
1. `action` (*Object*<sup>†</sup>): Простой объект описывающий изменения, которые имеют смысл для вашего приложения. Действия являются единственным способом получения данных из хранилища, т.ч. любые данные, будь то события UI, сетевые колбеки или другие источники, такие как вебсокеты, нуждаются, в конечном счете, быть направлеными как действия. Действия должны иметь поле `тип (type)`, для того чтобы указывать какой тип действия будет выполнен. Типы могут быть определены, как константы и импортироваться из других модулей. Лучше всего использовать строки (strings) для `типов`, чем символы ([Symbols](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol)), потому что строки сериализуемы. Если вам интересно, то посмотрите [Flux Standard Action](https://github.com/acdlite/flux-standard-action) рекомендации о том, как действия могут быть построены.

#### Возвращает

(Object<sup>†</sup>): Посланное действие

#### Заметки

<sup>†</sup> «Ванильная» реализация хранилища, полученная вызовом [`createStore`](createStore.md), поддерживает только простые объекты действий, передаваемые непосредственно редюсеру.

Однако, если вы оборачиваете [`createStore`](createStore.md) в [`applyMiddleware`](applyMiddleware.md), мидлвэры (middleware) могут интерпретировать действия по-разному и обеспечивать поддержку для отправки асинхронных действий (async actions). Асинхронных действия - это обычно асинхронные примитивы, типа Промисов (Promises), Наблюдателей (Observables), или преобразователей (thunks).

Мидлвэр созданы сообществом и не поставляются с Redux по умолчанию. Вы должны явно установить пакеты, такие как [redux-thunk](https://github.com/gaearon/redux-thunk) или [redux-promise](https://github.com/acdlite/redux-promise) для их использования. Вы также можете создать свои собственные мидлвэры. 

Чтобы узнать, как описать асинхронный вызов API, для чтения текущего состояния внутри генераторов действий, выполнения побочных эффектов или для выполнения последовательности цепочек, посмотрите пример использования [`applyMiddleware`](applyMiddleware.md).

#### Пример

```js
import { createStore } from 'redux'
let store = createStore(todos, [ 'Use Redux' ])

function addTodo(text) {
  return {
    type: 'ADD_TODO',
    text
  }
}

store.dispatch(addTodo('Прочитать документацию'))
store.dispatch(addTodo('Прочитать о мидлвэрах'))
```

<hr>

### <a id='subscribe'></a>[`subscribe(listener)`](#subscribe)
Добавляет слушателя. Он будет вызываться каждый раз, когда действие отправлено и некоторая часть дерева состояния могла потенциально измениться. Вы можете затем вызвать [`getState()`](#getState),  для того, чтобы прочитать текущее состояние дерева хранилища внутри обратного вызова.

Это низкоуровневое API. Скорее всего, вместо использования этого напрямую, вы будете использовать React (или другое) связки. Если вы чувствуете, что обратный вызов должен быть вызван с текущим состоянием, вы можете [преобразовать хранилище в Observable или написать свой `observeStore`](https://github.com/reactjs/redux/issues/303#issuecomment-125184409).

Для отписки слушателя, вызовите функцию возвращенную `subscribe`.

#### Параметры 

1. `listener` (*Function*): Колбэк будет вызван в любое время когда действие может быть отправлено и состояние может быть изменено. Вы можете вызвать [`getState()`](#getState) внутри колбэка, для того чтобы прочитать текущее состояние. Разумно ожидать, что редюсер хранилища - это  чистая функция, т.ч. вы можете сравнить ссылки на некоторый глубокий путь в состоянии, чтобы узнать, изменилось ли его значение.

##### Возвращает

(*Function*): Функция которая отписывает слушателя.

##### Примеры

```js
function select(state) {
  return state.some.deep.property
}

let currentValue
function handleChange() {
  let previousValue = currentValue
  currentValue = select(store.getState())
  
  if (previousValue !== currentValue) {
    console.log('Некоторое глубокое вложенное свойство измененное от ', previousValue, 'к', currentValue)
  }
}

let unsubscribe = store.subscribe(handleChange)
handleChange()
```

<hr>

### <a id='replaceReducer'></a>[`replaceReducer(nextReducer)`](#replaceReducer)

Заменяет редюсер, который в настоящее время используется хранилищем, чтобы вычислить состояние. Это усовершенствованное API. Вам возможно понадобится это, если ваше приложение реализует разделение кода и вы хотите загрузить некоторые редюсеры динамично. Вам также это может понадобиться, если вы реализуете горячий механизм перезагрузки для Redux.

#### Параметры

1. `reducer` (*Function*) Следующий редюсер для хранилища который будет использован.
